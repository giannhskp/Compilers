Μεταγλωττιστές - Project 3

Ιωάννης Καπετανγεώργης
Α.Μ. : 1115201800061

Directory Structure
--------------------

Project3
├── javacc5.jar
├── jtb132di.jar
├── minijava.jj
├── README.txt
├── Makefile
├── Main.java
├── MyVisitors
│   ├── Visitor1.java
│   ├── Visitor2.java
│   ├── CreateVtableVisitor.java
│   ├── CodeGeneratorVisitor.java
│   └── Scope.java
├── VTable
│   ├── VTable.java
│   ├── ResgisterSet.java
└── SymbolTable
    ├── SymbolTable.java
    ├── DefinedVariable.java
    ├── FunctionKey.java
    └── OffsetSet.java


Compilation & Execution
-----------------------
Στο directory Project3 υπάρχει Makefile.
Για το compilation εκτελούμε την εντολή:
  make compile
  (ή σκέτο: make)

Για την εκτέλεση του προγράμματος εκτελούμε την εντολή:
	java Main [file1] [file2] ... [fileN]
Παρατηρήσεις σχετικά με την εκτέλεση:
- Για να εκτελεστεί η παραπάνω εντολή πρέπει να βρισκόμαστε εσωτερικά του directory Project3, δηλαδή του directory όπου περιέχεται το Makefile αλλά και το αρχείο Main.java.
- Τα αρχεία javacc5.jar και jtb132di.jar πρέπει να βρίσκονται επίσης εσωτερικά του directory Project 3, όπως φαίνεται και το directory structure.
- Για την εκτέλεση του προγράμματος δίνουμε ένα ή περισσότερα input files, όπως περιγράφεται και την εκφώνηση της εργασίας.

Για να διαγράψουμε όλα τα αρχεία που έχουν παραχθεί εκτελούμε: make clean

Output του προγράμματος
-----------------------
- Το output του προγράμματος (δηλαδή ο κώδικας LLVM IR) παράγεται σε ένα αρχείο εξόδου. Το όνομα του αρχείου εξόδου έχει το αντίστοιχο όνομα με το αρχείο εισόδου με την κατάληξη .ll . Για παράδειγμα, αν δοθεί σαν input το αρχείο inputFile.java τότε το output θα παραχθεί στο αρχείο inputFile.ll . Σε περίπτωση που το αρχείο εισόδου δεν έχει την κατάληξη .java τότε το όνομα του αρχείου εξόδου είναι το ίδιο με αυτό της εισόδου με την κατάληξη .ll στο τέλος (δηλαδή δεν μπορεί να αντικατασταθεί το .java με το .ll)
- Επίσης έπειτα από την εκτέλεση, εκτυπώνεται στο stdout το αν το αρχείο είναι σημασιολογικά σωστό καθώς και το όνομα του αρχείου στο οποίο παράχθηκε ο κώδικας LLVM IR.


Παρατήρηση
----------
Κάθε σημείο κώδικα είναι πλήρως σχολιασμένο και εξηγείται αναλυτικά η κάθε λειτουργία που έχω υλοποιήσει.


Visitors
--------
Αρχικά εκτελούνται οι δύο visitors της εργασίας 2 (Visitor1 και Visitor2) οι οποίοι ελέγχουν σημασιολογικά το αρχείο και υπολογίζουν τα offsets.
Στην συνέχεια εκτελούνται οι δύο visitors οι οποίοι έχω υλοποιήσει για την εργασία 3 (CreateVtableVisitor και CodeGeneratorVisitor) οι οποίοι είναι υπεύθυνοι για την παραγωγή του κώδικα LLVM IR.
Οι υλοποιήσεις των visitors περιέχονται στο directory MyVisitors.

CreateVtableVisitor
--------------------
O visitor αυτός αναλαμβάνει και υλοποιεί τα εξής:
- Δημιουργία του Vtable της κάθε κλάσης
- Γράφει (emit) το Vtable της κάθε κλάσης στο αρχείο output
- Επίσης γράφει τις βοηθητικές συναρτήσεις που δίνονται στην εκφώνηση καθώς και τα απαραίτητα declares. Οι βοηθητικές συναρτήσεις που ορίζονται είναι οι print_int και throw_oob. Τα declares που γίνονται αφορούν την calloc, την printf και την exit.
Έτσι, έπειτα από την εκτέλεση του CreateVtableVisitor έχουν δημιουργηθεί και έχουν οριστεί στο αρχείο εξόδου τα vtables όλων των κλάσεων και έπειτα ορίζονται οι βοηθητικές συναρτήσεις.
Αναλυτικότερα για το πως κατασκευάζονται τα vtables αλλά και το τι περιέχουν εξηγείται στην αμέσως επόμενη παράγραφο.


VTable
-------
Για την υλοποίηση του VTable και την αποθήκευση όσων πληροφοριών είναι απαραίτητες χρησιμοποιώ 2 HashMaps.
Το βασικό HashMap είναι το ClassFunctions, το οποίο είναι τύπου Map<String, Map<String,String>>, δηλαδή σε κάθε κλειδί του ClassFunctions αντιστοιχεί και ένα Map.
Τα κλειδία του ClassFunctions είναι τα ονόματα των κλάσεων, δηλαδή έχουμε μια "εγγραφή" για κάθε κλάση. 
Έτσι, σε κάθε κλάση αντιστοιχεί και ένα  Map<String,String>. To Map αυτό περιέχει τις συναρτήσεις της κάθε κλάσης. 
Πιο συγκεκριμένα, έχει σαν κλειδί το όνομα της συνάρτησης και σαν item το όνομα της κλάσης στην οποία έχει οριστεί η συνάρτηση αυτή (έτσι ώστε να έχουμε την πληροφορία στις περιπτώσεις όπου μια κλάση κληρονομεί συναρτήσεις χωρίς να τις κάνει override).
Έτσι, κατά την εκτέλεση του CreateVtableVisitor κάθε φορά που κάνουμε visit μια συνάρτηση προσθέτουμε αυτήν την συνάρτηση στο Vtable της αντίστοιχης κλάσης.
Σε περίπτωση που μια κλάση κάνει extend μια άλλη, τότε το Vtable της αρχικοποιείται με το Vtable της κλάσης την οποία κάνει extend. Δηλαδή περιέχει όλες τις συναρτήσεις τις υπερκλάσης. Από εκεί και πέρα προστίθενται όσες νέες συναρτήσεις υλοποιούνται στην κλάση αυτή. Στην περίπτωση που μια συνάρτηση γίνεται override, δηλαδή υπάρχει ήδη στο Vtable, τότε απλά αλλάζει το όνομα της κλάσης στην οποία ορίζεται η συνάρτηση αυτή.
Τέλος, χρησιμοποιώ ένα βοηθητικό Map με όνομα MethodCount το οποίο περιέχει τον αριθμό των συναρτήσεων που έχει η κάθε κλάση (προφανώς συμπεριλαμβανομένων και των συναρτήσεων που "κληρονομεί" από την υπερκλάση) έτσι ώστε να οριστεί κατάλληλα το μέγεθος του Vtable στο κώδικα LLVM IR.


CodeGeneratorVisitor
--------------------
Αφού εκτελεστεί ο CreateVtableVisitor και έχει παραχθεί ο κώδικας για τον ορισμό των Vtables και τον βοηθητικών συναρτήσεων, εκτελείται ο CodeGeneratorVisitor ο οποίος είναι υπεύθυνος για την παραγωγή του κώδικα όλων των συναρτήσεων.
Ο CodeGeneratorVisitor χρησιμοποιεί πληροφορίες από το Vtable, τα offsets που έχουν παραχθεί από την εργασία 2 καθώς και κάποιες επιπλέον βοηθητικές πληροφορίες που υπάρχουν ήδη από την εργασία 2 έτσι ώστε να μην χρειαστεί να τις ξανά υπολογίσει.
Κάποιες βασικές πληροφορίες για τον CodeGeneratorVisitor είναι:
- Εντός κάθε συνάρτησης χρησιμοποιώ ένα βοηθητικό Map (RegisterMap). To Map αυτό περιέχει σαν κλειδιά τα ονόματα όλων των μεταβλητών που είτε δίνονται σαν ορίσματα στην συνάρτηση είτε δηλώνονται εσωτερικά αυτής. Σαν τιμές περιέχουν τους καταχωτητές που αντιστοιχούν στην κάθε μεταβλητή (δηλαδή τους καταχωτητές στους οποίους έγινε το αντίστοιχο alloca).
- Σε κάθε συνάρτηση γίνεται reset ο register counter σε 0. Έτσι στην υλοποίηση της κάθε συνάρτησης ο πρώτος καταχωρητής που χρησιμοποιείται είναι ο %_0 και κάθε νέος καταχωρητής αυξάνεται κατά 1.
- Σε κάθε συνάρτηση ο πρώτος καταχωτητής (δηλαδή ο % _0) αντιστοιχεί στο ίδιο το αντικείμενο το οποίο κλήθηκε η συνάρτηση (δηλαδή στο this).
- Κάθε φορά που δηλώνεται μια νέα μεταβλητή εσωτερικά μιας συνάρτησης, πέρα από το απαραίτητο allocation (μέσω της alloca), ακολουθεί και μια αρχικοποίηση της μεταβλητής αυτής (μέσω τις store). Πιο συγκεκριμένα, οι μεταβλητές τύπου int αρχικοποιούνται σε 0, οι μεταβλητές τύπου boolean αρχικοποιούνται σε false και οι pointers (δηλαδή είτε int[] είτε κάποιο αντικείμενο κλάσης) αρχικοποιούνται σε null.
- Για τους διαχείριση πινάκων ακεραίων αποθηκεύω το μέγεθος του κάθε πίνακα στην πρώτη του θέση. Επομένως κάθε φορά που δεσμεύεται ένας πίνακας, στην πραγματικότητα το μέγεθος του πίνακα που δεσμεύεται είναι κατά ένα μεγαλύτερο από αυτό που "ζητείται". Κατ΄ επέκταση κάθε φορά που γίνεται dereference ένα στοιχείο του πίνακα (δοθέντος ενός index) στην πραγματικότητα προσπελαύνουμε την θέση κατά 1 μεγαλύτερη από αυτήν που "δόθηκε".
- Κατά την δέσμευση ενός νέου πίνακα, ελέγχεται αν το μέγεθος που δόθηκε είναι <=0 και αν είναι εκτυπώνεται το αντίστοιχο error και η εκτέλεση τερματίζεται.
- Αντίστοιχα, κατά την προσπέλαση ενός στοιχείου ενός πίνακα ελέγχεται αν το index που δόθηκε είναι 0 <= index < μέγεθος_πίνακα και αν δεν είναι εκτυπώνεται το αντίστοιχο error (out of bounds) και η εκτέλεση τερματίζεται.
- Για την υλοποίηση των AndExpressions (&&) ελέγχεται πρώτα το πρώτο expression και μόνο αν είναι αληθές ελέγχεται και το δεύτερο, δηλαδή όπως ακριβώς έχουμε διδαχθεί και στο μάθημα. Για την υλοποίηση του χρησιμοποιούνται τα κατάλληλα labels καθώς και η phi.


Έχουν γίνει override όλες οι απαραίτητες συναρτήσεις visit. Κάθε μία παράγει τον LLVM IR κώδικα που αντιστοιχεί. Λεπτομέρειες εξηγούνται πολύ αναλυτικά στα σχόλια της κάθε συνάρτησης visit, δηλαδή εξηγείται στο γιατί γίνεται το κάθε emit, σε τι αποσκοπεί αλλά και εξηγούνται οποιεσδήποτε άλλες προγραμματιστικές λεπτομέρειες και επιλογές που έχω υλοποιήσει.


Αφού εκτελεστεί ο CodeGeneratorVisitor έχει παραχθεί o κώδικας LLVM IR στο αντίστοιχο αρχείο εξόδου, τον οποίο μπορούμε να κάνουμε compile μέσω του clang-4.0 και στην συνέχεια να τον εκτελέσουμε.




