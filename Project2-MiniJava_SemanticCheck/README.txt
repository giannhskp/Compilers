Μεταγλωττιστές - Project 2

Ιωάννης Καπετανγεώργης
Α.Μ. : 1115201800061

Directory Structure
--------------------

Project2
├── javacc5.jar
├── jtb132di.jar
├── minijava.jj
├── README.txt
├── Makefile
├── Main.java
├── MyVisitors
│   ├── Visitor1.java
│   ├── Visitor2.java
│   └── Scope.java
└── SymbolTable
    ├── SymbolTable.java
    ├── DefinedVariable.java
    ├── FunctionKey.java
    └── OffsetSet.java


Compilation & Execution
-----------------------
Στο directory Project2 υπάρχει Makefile.
Για το compilation εκτελούμε την εντολή:
  make compile
  (ή σκέτο: make)

Για την εκτέλεση του προγράμματος εκτελούμε την εντολή:
	java Main [file1] [file2] ... [fileN]
Παρατηρήσεις σχετικά με την εκτέλεση:
- Για να εκτελεστεί η παραπάνω εντολή πρέπει να βρισκόμαστε εσωτερικά του directory Project2, δηλαδή του directory όπου περιέχεται το Makefile αλλά και το αρχείο Main.java.
- Τα αρχεία javacc5.jar και jtb132di.jar πρέπει να βρίσκονται επίσης εσωτερικά του directory Project 2, όπως φαίνεται και το directory structure.
- Για την εκτέλεση του προγράμματος δίνουμε ένα ή περισσότερα input files, όπως περιγράφεται και την εκφώνηση της εργασίας.

Για να διαγράψουμε όλα τα αρχεία που έχουν παραχθεί εκτελούμε: make clean

Output του προγράμματος
-----------------------
- Αρχικά, εκτυπώνεται το όνομα του αρχείο που ελέγχεται
- Στην συνέχεια εκτυπώνεται το αν το αρχείο που ελέγχθηκε είναι σημασιολογικά σωστό η όχι. Σε περίπτωση που δεν είναι, εκτυπώνεται το αντίστοιχο μήνυμα λάθους.
- Σε περίπτωση που το αρχείο ήταν σημασιολογικά σωστό, εκτυπώνονται τα offsets των μεταβλητών/συναρτήσεων. Η μορφοποίηση των offset που εκτυπώνονται είναι παρόμοια με αυτή των ενδεικτικών αποτελεσμάτων που μας δόθηκαν.

Visitors
--------
Για τον σημασιολογικό έλεγχο έχω υλοποιήσει δυο Visitors, οι υλοποιήσεις των οποίων βρίσκονται στο directory MyVisitors.
Αρχικά "εκτελείται" ο πρώτος visitor (Visitor1) και στην συνέχεια ο δεύτερος (Visitor2). Αφού εκτελεστούν και οι δυο, το αρχείο έχει ολοκληρωθεί ο σημασιολογικός έλεγχος του αρχείου.

Visitor1
--------
Ο πρώτος visitor είναι υπεύθυνος να "συγκεντρώσει" όλες τις δηλώσεις. Δηλαδή, ελέγχει όλες τις δηλώσεις κλάσεων, μεταβλητών και συναρτήσεων. Όλες αυτές οι δηλώσεις αποθηκεύονται σε symbolTables. Περισσότερα για τα symbolTables εξηγούνται στην συνέχεια. Οι συναρτήσεις visit του πρώτου visitor παίρνουν σαν όρισμα ένα αντικείμενο τύπου Scope, το οποίο αντιπροσωπεύει το τρέχων scope που βρισκόμαστε.
Ο ορισμός της κλάσης Scope βρίσκεται στο αρχείο Scope.java. Ένα scope καθορίζεται από το όνομα της κλάσης και το όνομα της συνάρτησης. Όταν το scope δεν βρίσκεται εσωτερικά μιας συνάρτησης τότε το Scope περιέχει και στα δύο πεδία το όνομα της κλάσης.
Για παράδειγμα: το scope μιας δήλωσης ενός πεδίου μιας κλάσης είναι <ΌνομαΚλάσης , ΌνομαΚλάσης>, αντίστοιχα το scope μιας δήλωσης μιας μεταβλητής μέσα σε μια συνάρτηση είναι <ΌνομαΚλάσης , ΌνομαΣυνάρτησης>.
Για την "αποθήκευση" των δηλώσεων στα αντίστοιχα tables χρησιμοποιούνται οι εξής συναρτήσεις:
- classDec : για τις δηλώσεις κλάσεων
- varDec : για τις δηλώσεις μεταβλητών
- funDec : για τις δηλώσεις συναρτήσεων
Οι υλοποιήσεις των συναρτήσεων αυτών υπάρχουν στο αρχείο SymbolTable.java και οι λεπτομέρειες υλοποίησης τους εξηγούνται αναλυτικά στα σχόλια του κώδικα.
Τέλος, ο πρώτος visitor, εκτός από το να συγκεντρώνει και να αποθηκεύει τις δηλώσεις, ελέγχει και για ασυνέπειες μεταξύ αυτών. Πιο συγκεκριμένα ελέγχει:
- Αν υπάρχουν δηλώσεις μεταβλητών με ίδιο όνομα στο ίδιο scope.
- Αν υπάρχουν δηλώσεις συναρτήσεων με το ίδιο όνομα στην ίδια κλάση (overloading)
- Αν υπάρχει ασυνεπές overriding μιας συνάρτησης με την αντίστοιχη συνάρτηση της υπερκλάσης.
- Αν υπάρχουν δυο κλάσεις με ίδιο όνομα.
- Αν μια κλάση κάνει extend μια άλλη κλάση η οποία δεν έχει δηλωθεί, ή δεν έχει δηλωθεί ακόμα (καθώς οι υπερκλάσεις πρέπει να δηλώνονται πριν από τις υποκλάσεις).

Visitor2
--------
Όπως αναφέρθηκε έπειτα από την εκτέλεση του Visitor1, έχουν εντοπιστεί όλες οι δηλώσεις μεταβλητών, συναρτήσεων και κλάσεων των οποίων οι πληροφορίες έχουν αποθηκευτεί σε tables της κλάσης SymbolTable. Χρησιμοποιώντας τα tables αυτά, ο Visitor2 συνεχίζει τον σημασιολογικό έλεγχο, κάνοντας ελέγχους των τύπων των εκφράσεων. Για τους ελέγχους αυτούς χρησιμοποιούνται συναρτήσεις οι οποίες έχουν υλοποιηθεί στην κλάση symbolTable. Οι συναρτήσεις αυτές εξηγούνται συνοπτικά στην συνέχεια και αναλυτικά στα σχόλια του κώδικα. 
Ομοίως με τον Visitor1 oι συναρτήσεις visit παίρνουν σαν όρισμα ένα αντικείμενο τύπου Scope, έτσι ώστε να "γνωρίζει" κάθε στιγμή το τρέχον scope.
Κάποιοι από τους βασικούς ελέγχους που κάνει ο Visitor2 είναι:
- Έλεγχος συμβατότητας των τύπων μιας ανάθεσης/έκφρασης.
- Έλεγχος για το αν έχει δηλωθεί μια μεταβλητή που περιέχεται σε μια έκφραση και αν ο τύπος αυτής είναι συμβατός με την έκφραση.
- Έλεγχος συμβατότητας του τύπου που επιστρέφει μια συνάρτηση.
- Έλεγχος για το αν μια κλήση συνάρτησης έχει ίδιο αριθμό ορισμάτων με τον ορισμό της, αλλά και για το αν οι τύποι αυτών "συμφωνούν" με αυτούς της δήλωσης.
Προφανώς γίνονται πολλοί ακόμα έλεγχοι, οι οποίοι εξηγούνται αναλυτικά στα σχόλια του κώδικα.

SymbolTable
------------
Για την υλοποίηση του SymbolTable και την αποθήκευση όσων πληροφοριών είναι απαραίτητες για τον σημασιολογικό έλεγχο χρησιμοποιώ 3 HashMaps. Επίσης, χρησιμοποιώ 2 επιπλέον HashMaps για τον υπολογισμό των offsets τα οποία και εξηγούνται στην συνέχεια στην αντίστοιχη παράγραφο.
Πιο συγκεκριμένα, τα 3 HashMaps που χρησιμοποιώ είναι:
- ClassInherits τύπου: HashMap<String,String>
- ClassVariables τύπου: HashMap<DefinedVariable,String>
- FunctionDeclarations τύπου: HashMap<FunctionKey,List<String>>

ClassInherits
- - - - - - - -
Χρησιμοποιείται για την αποθήκευση των δηλωμένων κλάσεων. Το "κλειδί" του HashMap είναι το όνομα της κλάσης, ενώ η τιμή που αντιστοιχεί στο κάθε κλειδί είναι η κλάση την οποία κάνει extend. Εάν μια κλάση δεν κάνει extend κάποια άλλη τότε σαν τιμή έχει επίσης το όνομα της κλάσης. Με άλλα λόγια, οι κλάσεις που δεν κάνουν extend κάποια κλάση, έχουν σαν κλειδί και σαν τιμή το όνομα τους.
Κάθε φορά που ο Visitor1 "εντοπίζει" μια δήλωση κλάσης, την εισάγει στο HashMap.
Στον Visitor2, για να ελέγξουμε αν μια κλάσει έχει οριστεί, ελέγχουμε αν υπάρχει το όνομα της κλάσης αυτής σαν κλειδί του λεξικού.
Επίσης, αν θέλουμε να βρούμε την υπερκλάση μιας κλάσης, παίρνουμε την τιμή που αντιστοιχεί στο κλειδί/όνομα της κλάσης. Αν μας επιστραφεί το ίδιο όνομα που δώσαμε σαν κλειδί, σημαίνει ότι η κλάση δεν έχει υπερκλάση.

ClassVariables
- - - - - - - -
Χρησιμοποιείται για την αποθήκευση των δηλωμένων μεταβλητών/πεδίων κλάσεων. Το κλειδί του HashMap είναι ένα αντικείμενο τύπου DefinedVariable. Τα αντικείμενα τύπου DefinedVariable περιέχουν: το όνομα της μεταβλητής, το όνομα της κλάσης στην οποία δηλώθηκαν και το όνομα της συνάρτησης μέσα στην οποία δηλώθηκαν. Αν η μεταβλητή πρόκειται για πεδίο κλάσης τότε περιέχει τόσο στο όνομα της κλάσης όσο και στο όνομα της συνάρτησης το όνομα της συνάρτησης στην οποία δηλώθηκε. Έτσι μέσω ενός αντικειμένου DefinedVariable μπορούμε να χαρακτηρίσουμε μοναδικά μια δηλωμένη μεταβλητή ή ένα πεδίο μιας κλάσης.
Επομένως το ClassVariables HashMap, έχει σαν κλειδί ένα DefinedVariable και σαν τιμή τον τύπο της μεταβλητής/πεδίου που χαρακτηρίζεται από το DefinedVariable.
Όταν ο Visitor1 εντοπίσει μια δήλωση μεταβλητής/πεδίου την εισάγει στο ClassVariables HashMap.
Έτσι, ο Visitor2 έχει όλες τις πληροφορίες που χρειάζεται για όλες τις δηλωμένες μεταβλητές/πεδία, δηλαδή: το όνομα τους, το scope στο οποίο δηλώθηκαν αλλά και τον τύπο τους.

FunctionDeclarations
- - - - - - - - - - -
Χρησιμοποιείται για την αποθήκευση των δηλωμένων συναρτήσεων. Το κλειδί του HashMap είναι ένα αντικείμενο τύπου FunctionKey. Τα αντικείμενα τύπου FunctionKey περιέχουν: το όνομα της συνάρτησης και το όνομα της κλάσης "μέσα" στην οποία έχουν δηλωθεί. Έτσι, χαρακτηρίζεται μοναδικά κάθε δηλωμένη συνάρτηση. Σε κάθε κλειδί (δηλαδή σε κάθε συνάρτηση) αντιστοιχεί σαν τιμή μια λίστα. Η λίστα αυτή περιέχει: στην πρώτη θέση τον τύπο επιστροφής της συνάρτησης και στην συνέχεια τους τύπους των ορισμάτων που δέχεται. Για παράδειγμα στην πρώτη θέση της λίστας περιέχεται ο τύπος επιστροφής, στην δεύτερη θέση της λίστας ο τύπος του πρώτου ορίσματος κ.ο.κ.. Αν η συνάρτηση δεν δέχεται κανένα όρισμα τότε η λίστα περιέχει μόνο τον τύπο επιστροφής.
Επομένως το FunctionDeclarations HashMap, έχει σαν κλειδί ένα FunctionKey και σαν τιμή τον τύπο επιστροφής και τους τύπους των ορισμάτων της συνάρτησης που χαρακτηρίζεται από το FunctionKey.
Όταν ο Visitor1 εντοπίσει μια δήλωση συνάρτησης την εισάγει στο FunctionDeclarations HashMap.
Έτσι, ο Visitor2 χρησιμοποιόντας αυτό το HashMap μπορεί να εντοπίσει:
- Αν μια συνάρτηση έχει δηλωθεί σε μια κλάση
- Καθώς και να ελέγξει αν οι τύποι των ορισμάτων καθώς και ο αριθμός των ορισμάτων μιας κλήσης συνάρτησης "συμβαδίζουν" με τον ορισμό της συνάρτησης αυτής.

Χρησιμοποιώντας τα 3 αυτά HashMaps πραγματοποιείται η "δεύτερη φάση" του σημασιολογικού ελέγχου από τον Monitor2. Πιο συγκεκριμένα, ο Visitor2 χρησιμοποιεί της εξής συναρτήσεις:
- checkExpressionType : η οποία ελέγχει αν ένα expression έχει ίδιο τύπο με αυτόν που περιμένουμε να έχει. Σε περίπτωση που είναι διαφορετικού τύπου, παράγει Exception.
- checkAssignmentTypes : η οποία ελέγχει αν ένα assignment είναι σημασιολογικά σωστό. Δηλαδή, βρίσκει τον τύπο του "αριστερού μέρους" ενός assignment και μέσω της  checkExpressionType ελέγχει αν το "δεξί μέρος" έχει τον αντίστοιχο τύπο.
- checkFunctionCall: ελέγχει αν μια κλήση συνάρτησης (MessageSend) είναι σημασιολογικά σωστή. Δηλαδή, αρχικά ελέγχει αν το αντικείμενο πάνω στο οποίο καλείται η συνάρτηση αντιστοιχεί σε μια δηλωμένη κλάση (μέσω της συνάρτησης getFunCallerType η οποία καλείται αρχικά από την visit) και αν στην κλάση αυτή (η σε κάποια υπερκλάση της) έχει δηλωθεί η συνάρτηση αυτή. Στην συνέχεια ελέγχει αν το πλήθος των ορισμάτων είναι ίδιο με αυτό της δήλωσης της συνάρτησης αλλά και αν το κάθε όρισμα είναι του αντίστοιχου τύπου με αυτόν στην δήλωση της συνάρτησης. Ο τύπος του κάθε ορίσματος βρίσκεται μέσω της συνάρτησης getArgumentType η οποία καλείται από τον Visitor2 στην αντίστοιχη visit συνάρτηση.
- checkClassAllocation: ελέγχει αν ένα AllocationExpression είναι σημασιολογικά σωστό. Δηλαδή ελέγχει αν η κλάση αυτή έχει δηλωθεί.
- checkDeclarationType: ελέγχει αν μια δήλωση μεταβλητής είναι σημασιολογικά σωστή. Χρησιμοποιείται για της δηλώσεις αντικειμένων κλάσεων (π.χ. MyClass item;). Ελέγχεται αν η κλάση έχει δηλωθεί, καθώς κάτι τέτοιο δεν μπορεί να ανιχνευθεί από τον πρώτο visitor.

Οι υλοποιήσεις των συναρτήσεων αυτών υπάρχουν στο αρχείο SymbolTable.java. Όλες οι λειτουργίες εξηγούνται πολύ αναλυτικά στα σχόλια του κώδικα, καθώς εδώ έγινε μόνο μια πολύ συνοπτική περιγραφή τους. Επίσης στο αρχείο περιέχονται και άλλες "βοηθητικές" συναρτήσεις.




Υπολογισμός των Offsets
-----------------------
Για τον υπολογισμό των offsets χρησιμοποιώ 2 HashMaps, ένα για τις μεταβλητές και ένα για της συναρτήσεις. Τα δυο HashMaps είναι τύπου HashMap<String, List<OffsetSet>>. Κάθε κλειδί αντιστοιχεί στο όνομα μιας κλάσης. Κάθε κλειδί/κλάση έχει ως αντικείμενο μια λίστα από αντικείμενα τύπου OffsetSet. Κάθε ένα αντικείμενο τύπου OffsetSet αντιστοιχεί σε μια μεταβλητή/συνάρτηση και περιέχει το όνομα της, το offset της και το μέγεθος της.

VariableOffsets
- - - - - - - -
Χρησιμοποιείται για τον υπολογισμό των offsets των μεταβλητών. Κάθε κλειδί αντιστοιχεί σε μια κλάση. Κάθε κλάση έχει ως αντικείμενα μια λίστα με τις δηλωμένες μεταβλητές σε αυτήν (με την σειρά που δηλώθηκαν).
Κάθε φορά που ο Visitor1 εντοπίζει μια δήλωση ενός πεδίου μιας κλάσης εισάγει στην λίστα της αντίστοιχης κλάσης το πεδίο αυτό. 
Αν πρόκειται για το πρώτο πεδίο μιας κλάσης τότε:
- Αν η κλάση κάνει extend μια άλλη κλάση, βρίσκουμε το τελευταίο πεδίο που υπάρχει στην αντίστοιχη λίστα της υπερκλάσης και μέσω του offset του και του μεγέθους του πεδίου αυτού βρίσκουμε το offset του πρώτου πεδίου της νέας κλάσης.
- Αν η κλάση δεν κάνει extend κάποια άλλη τότε το πεδίο αυτό έχει offset 0.
Αν δεν πρόκειται για το πρώτο πεδίο μιας κλάσης τότε μέσω του offset και του μεγέθους του προηγούμενου πεδίου που δηλώθηκε στην κλάση αυτή, βρίσκουμε το offset του νέου πεδίου.
Έτσι όταν ολοκληρωθεί ο Visitor1, δηλαδή έχουν "ελεγχθεί" όλες οι κλάσεις, έχουν υπολογιστεί τα offsets όλων των πεδίων όλων των κλάσεων.
Σχετικά με τα μεγέθη μεταβλητών, θεωρούμε ότι: οι int έχουν μέγεθος 4, οι boolean έχουν μέγεθος 1 και οι int[] έχουν μέγεθος 8.
Περισσότερες λεπτομέρειες εξηγούνται στα σχόλια του κώδικα (κυρίως στην συνάρτηση varDec του SymnolTable.java)

FunctionOffsets
- - - - - - - -
Χρησιμοποιείται για τον υπολογισμό των offsets των συναρτήσεων. Κάθε κλειδί αντιστοιχεί σε μια κλάση. Κάθε κλάση έχει ως αντικείμενα μια λίστα με τις δηλωμένες συναρτήσεις σε αυτήν (με την σειρά που δηλώθηκαν).
Κάθε φορά που ο Visitor1 εντοπίζει μια δήλωση μιας συνάρτησης τότε:
- Ελέγχει αν η συνάρτηση αυτή κάνει override κάποια συνάρτηση μιας υπερκλάσης. Δηλαδή, ελέγχει στην υπερκλάση (και στην υπερκλάση της υπερκλάσης κ.ο.κ) για το αν υπάρχει συνάρτηση με το ίδιο όνομα (και προφανώς ίδιο τύπο). Αν υπάρχει, τότε "αγνοούμε" αυτήν την συνάρτηση, δηλαδή δεν την βάζουμε στην λίστα της νέας κλάσης και δεν υπολογίζουμε το offset της.
- Αν η συνάρτηση δεν κάνει override και πρόκειται για την πρώτη συνάρτηση της κλάσης, τότε:
 * Αν η κλάση κάνει extend μια άλλη κλάση, βρίσκουμε την τελευταία συνάρτηση που υπάρχει στην αντίστοιχη λίστα της υπερκλάσης και μέσω του offset του και του μεγέθους της βρίσκουμε το offset της πρώτης συνάρτησης της νέας κλάσης.
 * Αν η κλάση δεν κάνει extend κάποια άλλη τότε η συνάρτηση αυτή έχει offset 0.
- Αν η συνάρτηση δεν κάνει override και ΔΕΝ πρόκειται για την πρώτη συνάρτηση της κλάσης, τότε μέσω του offset και του μεγέθους της προηγούμενης συνάρτησης που δηλώθηκε στην κλάση αυτή, βρίσκουμε το offset του νέου πεδίου.
Έτσι όταν ολοκληρωθεί ο Visitor1, δηλαδή έχουν "ελεγχθεί" όλες οι κλάσεις, έχουν υπολογιστεί τα offsets όλων των συναρτήσεων όλων των κλάσεων.
Οι συναρτήσεις στην πράξη είναι pointer, επομένως θεωρούμε ότι όλες οι συναρτήσεις έχουν μέγεθος 8.
Περισσότερες λεπτομέρειες εξηγούνται στα σχόλια του κώδικα (κυρίως στην συνάρτηση funDec του SymnolTable.java)
















