Μεταγλωττιστές - Project 1

Ιωάννης Καπετανγεώργης
Α.Μ. : 1115201800061

PART 1
------

* Η υλοποίηση του part1 υπάρχει στο directory με όνομα part1.

Αρχική γραμματική:

exp -> num | exp op exp | (exp)

op -> + | - | **

num -> digit | digit num

digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

Μετατρέπουμε την γραμματική έτσι ώστε να υποστηρίζει την προτεραιότητα των πράξεων.
Για την προτεραιότητα ισχύει:
precedence(+)=precedence(-)<precedence(**)<precedence((exp))
Επίσης, λαμβάνουμε υπόψιν ότι οι πρόσθεση και η αφαίρεση είναι αριστερά προσεταιριστικές,
ενώ η ύψωση σε δύναμη είναι δεξιά προσεταιριστική.
Λαμβάνοντας υπόψιν τα παραπάνω, η νέα γραμματική που προκύπτει είναι:

exp -> exp + term
    |  exp - term
    |  term
term -> factor ** term
     |  factor
factor -> num
       |  ( exp )
num -> digit num
    |  digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

Η παραπάνω γραμματική περιέχει αριστερές αναδρομές και είναι ambiguous.
Επίσης η γραμματική επιτρέπει πολυψήφιους αριθμούς που ξεκινάνε με μηδέν (leading zeroes).
Όπως προτάθηκε στο piazza, καλό είναι η γραμματική μας να μην επιτρέπει τέτοιους αριθμούς επομένως μετασχηματίζω την γραμματική
έτσι ώστε να μην τους επιτρέπει.
Εφαρμόζοντας παραγοντοποίηση, αφαιρούμε τις αριστερές αναδρομές και καταλήγουμε στην εξής LL(1) γραμματική:

#1  exp -> term exp2
#2  exp2 -> + term exp2
#3       |  - term exp2
#4       |  ε
#5  term -> factor term2
#6  term2 -> ** term
#7        |  ε
#8  factor -> num
#9         |  ( exp )
#10 num -> positive_digit numTail
#11     |  0
#12 numTail -> positive_digit numTail
#13         |  0 numTail
#14         |   ε
#15 positive_digit -> 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9


Υπολογίζουμε τα FIRST+ των παραπάνω κανόνων:
FIRST+(#1) = FIRST(term) = FIRST(factor) = { 0...9 , ( }
FIRST+(#2) = { + }
FIRST+(#3) = { - }
FIRST+(#4) = FOLLOW(exp2) = FOLLOW(exp) = { $ , ) }
FIRST+(#5) = FIRST(factor) = { 0...9 , ( }
FIRST+(#6) = { ** }
FIRST+(#7) = FOLLOW(term2) = FOLLOW(term) = FIRST(exp2) U FOLLOW(exp2) = { + , - , $ , ) }
FIRST+(#8) = { 0...9 }
FIRST+(#9) = { ( }
FIRST+(#10) = { 1...9 }
FIRST+(#11) = { 0 }
FIRST+(#12) = { 1...9 }
FIRST+(#13) = { 0 }
FIRST+(#14) = FOLLOW(numTail) = FOLLOW(num) = FOLLOW(factor) = FIRST(term2) U FOLLOW(term2) =
            = FIRST(term2) U FOLLOW(term) = FIRST(term2) U FIRST(exp2) U FOLLOW(exp2) = { ** , + , - , $ , ) }
FIRST+(#15) = { 1...9 }

Παρατηρούμε ότι τα η τομή των FIRST+ των κανόνων (ανά δύο) κάθε μη τερματικού είναι το κενό σύνολο.
Επομένως, επαληθεύεται ότι η γραμματική είναι LL(1).
Κατασκευάζουμε το lookahead table:
               ____________________________________________________________________
              |    0    |  1...9  |   (   |   )   |   +   |   -   |   **   |   $   |
-----------------------------------------------------------------------------------|
exp           |   #1    |   #1    |   #1  | error | error | error |  error | error |
--------------|---------|---------|-------|-------|-------|-------|--------|-------|
exp2          |  error  |  error  | error |   #4  |   #2  |   #3  |  error |   #4  |
--------------|---------|---------|-------|-------|-------|-------|--------|-------|
term          |   #5    |   #5    |   #5  | error | error | error |  error | error |
--------------|---------|---------|-------|-------|-------|-------|--------|-------|
term2         |  error  |  error  | error |   #7  |   #7  |   #7  |   #6   |   #7  |
--------------|---------|---------|-------|-------|-------|-------|--------|-------|
factor        |   #8    |   #8    |   #9  | error | error | error |  error | error |
--------------|---------|---------|-------|-------|-------|-------|--------|-------|
num           |  #11    |  #10    | error | error | error | error |  error | error |
--------------|---------|---------|-------|-------|-------|-------|--------|-------|
numTail       |  #13    |  #12    | error |  #14  |  #14  |  #14  |   #14  |  #14  |
--------------|---------|---------|-------|-------|-------|-------|--------|-------|
positive_digit|  error  |  #15    | error | error | error | error |  error | error |
------------------------------------------------------------------------------------

Με βάση την γραμματική αυτή κατασκεύασα τον Calculator Parser του Part1 της εργασίας.
Η υλοποίηση του βρίσκεται στο αρχείο Parser.java.
Κάθε μη τερματικό αντιστοιχεί και σε μία συνάρτηση που το υλοποιεί, με εξαίρεση τα μη τερματικά num, numTail και positive_digit τα οποία "αναγνωρίζουν"
έναν αριθμό και υλοποιούνται από την συνάρτηση parseNumber.
Επίσης, η αριστερή προσεταιριστικότητα τις πρόσθεσης και της αφαίρεσης αλλά και η δεξιά προσεταιριστικότητα της ύψωσης σε δύναμη
υλοποιούνται προγραμματιστικά στους αντίστοιχους κανόνες/συναρτήσεις.
Τέλος έχει υλοποιηθεί η κλάση ParseException έτσι ώστε να διαχειρίζονται σωστά τα parse errors και να γίνεται το αντίστοιχο throw του exception.
Περισσότερες λεπτομέρειες σχετικά με την υλοποίηση εξηγούνται αναλυτικά στα σχόλια του κώδικα.

ΠΑΡΑΤΗΡΗΣΗ: Όπως προτάθηκε στο piazza, ο parser μου απορρίπτει είσοδο η οποία περιέχει αριθμούς που ξεκινάνε από 0, δηλαδή παράγει parse error.
Με εξαίρεση, προφανώς, τον αριθμό 0. Για παράδειγμα, η είσοδος: 2+03 δεν γίνεται αποδεκτή.

Compilation and Execution
-------------------------

Στο directory του part1 υπάρχει Makefile.
Για το compilation εκτελούμε την εντολή:
  make compile
  (ή σκέτο: make)

Για την εκτέλεση του προγράμματος εκτελούμε την εντολή:
  make execute
  (ή make run)
  Διαφορετικά τρέχουμε απευθείας το Parser.class αρχείο: java Parser

Για να διαγράψουμε τα .class αρχεία εκτελούμε: make clean

User Interface

Το εκτελέσιμο πρόγραμμα δέχεται σαν είσοδο μια αριθμητική παράσταση η οποία τελειώνει με /n ή EOF.
Σε περίπτωση που η είσοδος περιέχει κάποιον μη αποδεκτό χαρακτήρα, εκτυπώνεται parse error και η εκτέλεση τερματίζεται.
Διαφορετικά, υπολογίζεται η τιμή της παράστασης που δόθηκε, εκτυπώνεται το αποτέλεσμα και η εκτέλεση ολοκληρώνεται.

-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

PART 2
------
* Η υλοποίηση του part2 υπάρχει στο directory με όνομα part2.

Compilation and Execution
-------------------------

Στο directory του part2 υπάρχει Makefile.
Για το compilation εκτελούμε την εντολή:
  make compile
  (ή σκέτο: make)

Για την εκτέλεση του προγράμματος εκτελούμε την εντολή:
  make execute < input_file_path

  όπου input_file_path το path για το αρχείο εισόδου.

ΣΗΜΑΝΤΙΚΗ ΠΑΡΑΤΗΡΗΣΗ: Όπως αναφέρθηκε στο piazza, τα αρχεία .jar δεν περιέχονται στο παραδοτέο directory.
Επομένως, πρέπει να προστεθούν έτσι ώστε να μπορεί να γίνει το compilation/execution.
Τα αρχεία αυτά πρέπει να προστεθούν μέσα στο directory με όνομα part2, έτσι ώστε να μπορεί να τα "βρει" το Makefile.
Δηλαδή πρέπει να είναι εσωτερικά του directory part2 μέσα στο οποίο περιέχονται τα αρχεία scanner.flex, parser.cup αλλά και το Makefile.

Scanner (scanner.flex)
----------------------
O scanner του αρχείου scanner.flex παράγει τα εξής tokens:
  PLUS = '+'
  COMMA = ','
  LPAREN = '('
  RPAREN = ')'
  RBRACK = '}'
  PARBRACK = ')' ακολουθούμενο από '{' (και ίσως WhiteSpaces ενδιάμεσα)
  IF = if   (η "λέξη κλειδί" if)
  ELSE = else
  PREFIX = prefix
  SUFFIX = suffix
  IDENTIFIER = ονόματα μεταβλητών, συναρτήσεων
  STRING_LITERAL = συμβολοσειρές που περικλείονται από ""
Παρατηρήσεις:
  - Το token PARBRACK χρησιμοποιείται για τα declaration καθώς έχουμε πάντα έναν χαρακτήρα ')' ακολουθούμενο από '{'
    έπειτα από τα "ορίσματα" της συνάρτησης.
  - Έχουν οριστεί και τα Macros LineTerminator, WhiteSpace τα οποία o scanner αγνοεί.


Parser - Γραμματική  (parser.cup)
---------------------------------

Παρακάτω ακολουθούν κάποια χαρακτηριστικά της γραμματικής, δηλαδή τις "προϋποθέσεις" όπου πρέπει
να τηρεί το input έτσι ώστε να γίνει scanned/parsed σωστά και να παραχθεί το αντίστοιχο output.
Κάθε άλλη περίπτωση οδηγεί σε parse error.
Περαιτέρω λεπτομέρειες σχετικά με την γραμματική αλλά και την υλοποίηση της υπάρχουν στο αρχείο parser.cup.

Το input αποτελείται από 2 sections:
  - Το declaration section, στο οποίο υπάρχουν δηλώσεις συναρτήσεων
  - Το call section, στο οποίο υπάρχουν κλήσεις συναρτήσεων (top-level calls) ή (όπως αναφέρθηκε στο piazza) εκφράσεις που αποτιμώνται σε string
Στο input όλα τα declarations πρέπει να προηγούνται από τα calls.
Το declaration section αποτελείται από μηδέν ή περισσότερα declarations.
Το call section αποτελείται από μηδέν ή περισσότερα calls/εκφράσεις.

Declarations
------------
Ένα declaration είναι της μορφής:
  functionName ( arguments ) { block }
όπου:
  - functionName: ένας IDENTIFIER όπου αντιστοιχεί στο όνομα της συνάρτησης.
  - arguments: κανένας ή παραπάνω IDENTIFIERS. Σε περίπτωση που τα arguments περιέχουν παραπάνω από έναν
    IDENTIFIER πρέπει να χωρίζονται μεταξύ τους με ',' (COMMA).
    Αν σαν argument δοθεί οποιοσδήποτε άλλος τύπος, εκτός του IDENTIFIER, (π.χ. STRING_LITERAL) δεν γίνεται αποδεκτό,
    δηλαδή έχουμε ένα parse error.
  - block: μπορεί να περιέχει οποιαδήποτε απλή ή πολύπλοκη έκφραση, δηλαδή: IDENTIFIERS, STRING_LITERALS, function calls,
    if-else statements, concatenations. Εκφράσεις όπως τα function calls, τα if-else και τα concatenations μπορούν να
    αποτελούνται από άλλες πολύπλοκες εκφράσεις.

Λίστα εκφράσεων εσωτερικά της Main
---------------------------------
Στην λίστα εκφράσεων μπορεί να περιέχεται οποιαδήποτε έκφραση αποτιμάται σε ένα String. Δηλαδή εκτός από function calls,
μπορούμε να έχουμε string literals, string concatenations, if-else statement αλλά και οποιονδήποτε "συνδυασμό" αυτών.
Ένα top-level function call είναι της μορφής:
  functionName ( arguments )
όπου:
  - functionName: ένας IDENTIFIER όπου αντιστοιχεί στο όνομα της συνάρτησης.
  - arguments: καμία ή παραπάνω απλές ή/και πολύπλοκες εκφράσεις, υπό την προϋπόθεση ότι δεν περιέχουν IDENTIFIERS.
    Επομένως αποδεκτά ορίσματά σε ένα top-level function call είναι: STRING_LITERALS, function calls,
    if-else statements, concatenations. Εκφράσεις όπως τα function calls, τα if-else και τα concatenations πρέπει να
    μην περιέχουν κάποιον IDENTIFIER. Μπορούν να αποτελούνται από άλλες πολύπλοκες εκφράσεις, οι οποίες όμως αντίστοιχα
    δεν περιέχουν IDENTIFIERS.

ΠΑΡΑΤΗΡΗΣΗ:
Οι ορισμοί των function calls, if-else statements και concatenations διαφέρουν ανάλογα με το αν αυτά περιέχονται
εσωτερικά ενός declaration ή σαν όρισμα ενός top-level function call (στο call section). Όπως εξηγήθηκε παραπάνω, στην πρώτη
περίπτωση μπορούν να περιέχουν identifiers ενώ αντίθετα στην περίπτωση των top-level function call δεν μπορούν να περιέχουν identifiers.
Επίσης είναι προφανές, ότι ένα function call που βρίσκεται εσωτερικά του block ενός function declaration διαφέρει από ένα top-level call
που βρίσκεται στο call section του input για τον ίδιο λόγο με παραπάνω.

